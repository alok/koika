/-
  Koika/Interop.lean - Port of coq/Interop.v
  Exporting Koika programs for use with the cuttlec command-line tool

  Defines package structures for bundling together:
  - Type definitions and register specifications
  - Rules and schedulers
  - External function specifications
  - Verilog and simulation backend configurations
-/

import Koika.Types
import Koika.Primitives
import Koika.FiniteType
import Koika.Syntax
import Koika.TypedSyntax
import Koika.Compile.Lowered
import Koika.Compile.Lower
import Koika.Compile.Circuit
import Koika.Compile.Compiler

namespace Koika

/-! ## External Function Specifications -/

/-- RTL (Verilog) specification for an external function -/
structure ExtFnRtlSpec where
  /-- Name used in generated Verilog code -/
  name : String
  /-- Whether this is an internal module (true) or external I/O (false) -/
  internal : Bool
  deriving Repr

/-- Simulation (C++) specification for an external function -/
structure ExtFnSimSpec where
  /-- C++ function name (may include "template" prefix) -/
  name : String
  /-- Whether function needs pointer to simulator object -/
  method : Bool
  deriving Repr

/-! ## Empty External Function Type

For programs that don't use external functions, we provide an empty
external function type with empty implementations.
-/

/-- Empty external function type (for programs with no external functions) -/
inductive EmptyExtFn : Type where
  -- No constructors

/-- External signature for empty external functions -/
def emptyExtSig : EmptyExtFn → ExternalSig := nofun

/-- Empty external function implementation -/
def emptyExtImpl (fn : EmptyExtFn) : (emptyExtSig fn).argType.denote →
                                      (emptyExtSig fn).retType.denote :=
  nofun

/-- Lowered external signature for empty external functions -/
def emptyLoweredExtSig : EmptyExtFn → CExternalSig := nofun

/-- Lowered external function implementation -/
def emptyLoweredExtImpl (fn : EmptyExtFn)
    : BitVec (emptyLoweredExtSig fn).argSize → BitVec (emptyLoweredExtSig fn).retSize :=
  nofun

/-! ## Package Structures

These structures bundle together all the components needed to define
and compile a complete Koika program.
-/

section Packages

/-- Main Koika package: contains all information about a hardware module.

This structure bundles together:
- Type information (registers, rules, external functions)
- Register specifications (types, initial values)
- Rule definitions and scheduler
- Module metadata

Type parameters:
- `pos_t`: Position/location info (typically `Unit` or `String`)
- `var_t`: Variable names in let bindings (typically `String`)
- `fn_name_t`: Internal function names (typically `String`)
- `rule_name_t`: Rule names (typically an inductive type)
- `reg_t`: Register identifiers (typically an inductive type)
- `ext_fn_t`: External function names (typically an inductive type)
-/
structure KoikaPackage (pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t : Type) where
  /-- Register type mapping: maps each register to its Koika type -/
  regTypes : reg_t → Ty

  /-- Register initial values: provides initial value for each register -/
  regInit : (r : reg_t) → (regTypes r).denote

  /-- Finite type instance for registers (needed to enumerate all registers) -/
  regFinite : FiniteType reg_t

  /-- External function signatures: type signature for each external function -/
  extFnTypes : ext_fn_t → ExternalSig

  /-- Rule definitions: maps each rule name to its typed rule definition -/
  rules : rule_name_t → Rule reg_t ext_fn_t regTypes extFnTypes

  /-- Whether each rule should be implemented externally (native code) -/
  ruleExternal : rule_name_t → Bool

  /-- Scheduler: defines the order and conditions for rule execution -/
  scheduler : Scheduler pos_t rule_name_t

  /-- Module name: used in generated code and documentation -/
  moduleName : String

/-- Circuit package: adds compiled circuits to a Koika package.

This structure extends KoikaPackage with the compiled circuit representation.
It contains the actual hardware circuits generated by the compiler.
-/
structure CircuitPackage (pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t : Type) where
  /-- The underlying Koika package -/
  pkg : KoikaPackage pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t

  /-- Compiled scheduler circuits for register updates -/
  circuits : SchedulerCircuit reg_t ext_fn_t rule_name_t
                               (lowerR pkg.regTypes)
                               (lowerSigma pkg.extFnTypes)

/-- Verilog package: backend-specific configuration for Verilog generation -/
structure VerilogPackage (ext_fn_t : Type) where
  /-- Map from external functions to their RTL specifications.

      The 'internal' field indicates whether calls become:
      - true: internal module instantiations
      - false: input/output wires (external interface)

      The 'name' field is used to construct wire or module names. -/
  extFnSpecs : ext_fn_t → ExtFnRtlSpec

/-- Simulation package: backend-specific configuration for C++ simulation -/
structure SimPackage (ext_fn_t : Type) where
  /-- Map from external functions to their C++ specifications.

      The 'method' field indicates whether the function needs a pointer
      to the current simulator object (useful for mutating simulator internals).

      The 'name' field is the C++ function name, possibly prefixed with
      "template" if the function is templated. -/
  extFnSpecs : ext_fn_t → ExtFnSimSpec

  /-- Optional C++ prelude code.

      Should implement a class called 'extfuns' with public functions
      named consistently with extFnSpecs. Can also be a simple #include.
      Only needed if ext_fn_t is non-empty. -/
  prelude : Option String

end Packages

/-! ## Compilation

Functions for compiling Koika packages to circuits.
Note: Actual compilation is performed by the backend interfaces (see Backends namespace).
The circuit generation happens during the OCaml extraction phase.
-/

section Compilation

variable {var_t fn_name_t rule_name_t reg_t ext_fn_t : Type}
variable [DecidableEq reg_t]

/-- Compile a Koika package to a circuit package.

This is the main compilation function that transforms a high-level
Koika specification into low-level circuits. It:
1. Lowers typed rules to circuit-level representation
2. Compiles the scheduler with optimizations
3. Generates register update circuits

Note: This function requires pos_t = Unit (positions are erased during compilation).

Parameters:
- `pkg`: The Koika package to compile

Returns: A CircuitPackage containing the compiled circuits
-/
def compileKoikaPackage
    (pkg : KoikaPackage Unit var_t fn_name_t rule_name_t reg_t ext_fn_t)
    : CircuitPackage Unit var_t fn_name_t rule_name_t reg_t ext_fn_t :=
  { pkg := pkg
    circuits := compile_scheduler pkg.regTypes pkg.extFnTypes pkg.rules pkg.scheduler }

end Compilation

/-! ## Interop Package

Complete package with all backend configurations bundled together.
This is the top-level structure used by the cuttlec compiler.
-/

/-- Complete interop package for the cuttlec compiler.

This structure bundles together a Koika package with backend-specific
configurations for both Verilog and simulation. It uses standard types
for positions (Unit), variables (String), and function names (String).
-/
structure InteropPackage where
  /-- Position type (fixed to Unit for simplicity) -/
  pos_t : Type := Unit
  /-- Variable type (fixed to String) -/
  var_t : Type := String
  /-- Internal function name type (fixed to String) -/
  fn_name_t : Type := String
  /-- Register type (user-defined inductive) -/
  reg_t : Type
  /-- Rule name type (user-defined inductive) -/
  rule_name_t : Type
  /-- External function type (user-defined inductive) -/
  ext_fn_t : Type
  /-- The main Koika package -/
  koika : KoikaPackage pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t
  /-- Verilog backend configuration -/
  verilog : VerilogPackage ext_fn_t
  /-- Simulation backend configuration -/
  sim : SimPackage ext_fn_t

/-! ## Type Conversion Utilities

Functions for converting between struct types and lists.
These are useful for interoperating with extraction and external tools.
-/

section TypeConv

variable {A : Type}

/-- Convert a struct to a list of field-value pairs.

Parameters:
- `f`: Function to convert each typed field value to type A
- `fields`: List of (name, type) pairs defining the struct
- `v`: The struct value to convert

Returns: List of (field_name, converted_value) pairs
-/
def structToList (f : (tau : Ty) → tau.denote → A)
    : (fields : List (String × Ty)) → fieldsDenote fields → List (String × A)
  | [], _ => []
  | (nm, tau) :: fields, (val, rest) =>
      (nm, f tau val) :: structToList f fields rest

/-- Type of conversion functions for struct_of_list -/
def StructOfListFn (A : Type) :=
  A → Σ (tau : Ty), tau.denote

/-- Extract field type list from the conversion function -/
def structOfListFields (f : StructOfListFn A) (aa : List (String × A))
    : List (String × Ty) :=
  aa.map fun (nm, a) => (nm, (f a).1)

/-- Convert a list of field-value pairs to a struct.

Parameters:
- `f`: Function to convert each A value to a typed value
- `aa`: List of (name, value) pairs

Returns: A struct value with the appropriate type
-/
def structOfList (f : StructOfListFn A) (aa : List (String × A))
    : fieldsDenote (structOfListFields f aa) :=
  match aa with
  | [] => ()
  | (_, a) :: aa => ((f a).2, structOfList f aa)

end TypeConv

/-! ## Backend Interfaces

These axioms define the interface to the OCaml extraction backends.
In actual use, these are implemented by the OCaml cuttlec compiler.
-/

namespace Backends

/-- Compile to Verilog backend (implemented in OCaml) -/
axiom compileCircuits {pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t : Type} :
    KoikaPackage pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t →
    VerilogPackage ext_fn_t → Unit

/-- Compile to C++ simulation backend (implemented in OCaml) -/
axiom compileSimulation {pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t : Type} :
    KoikaPackage pos_t var_t fn_name_t rule_name_t reg_t ext_fn_t →
    SimPackage ext_fn_t → Unit

/-- Compile all backends (implemented in OCaml) -/
axiom compileAll : InteropPackage → Unit

/-- Register a package with the compiler registry (implemented in OCaml) -/
axiom register : InteropPackage → Unit

end Backends

end Koika
